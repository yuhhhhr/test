<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Panorama + FBX Viewer</title>
  <meta name="description" content="Renders a 360Â° panorama as background and a centered FBX character on top. No UI." />
  <meta name="theme-color" content="#111827" />
  <style>
    html, body { height: 100%; margin: 0; background:#000; }
    #app { position: fixed; inset: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
  <!-- If you keep panorama.js in the same folder, this will load it.  -->
  <!-- Tip: When hosting from GitHub, use the RAW URL, not the blob page. -->
  <script src="./panorama.js" defer></script>
</head>
<body>
  <div id="app"></div>

  <!-- Three.js + FBXLoader (ES modules) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { FBXLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    // ====== CONFIGURE YOUR ASSETS HERE ======
    const PANORAMA_IMAGE = 'https://i.imgur.com/2CFfaIJ.jpeg';   // Namek
    const FBX_MODEL_URL  = './character.fbx';                   // Replace with your model path

    // ====== CORE SETUP ======
    const container = document.getElementById('app');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.65, 3.5); // eye-level-ish

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    // Soft, neutral lighting for character
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    hemi.position.set(0, 2, 0);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(3, 5, 2);
    dir.castShadow = false;
    scene.add(dir);

    // Controls (mouse only, no UI). Feel free to remove if you want static view.
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.rotateSpeed = 0.5;

    // ====== PANORAMA BACKDROP ======
    // If your panorama.js exposes a helper, we will try to use it.
    // Otherwise we fall back to a native Three.js inverted sphere.
    function addPanoramaFallback(url){
      const textureLoader = new THREE.TextureLoader();
      textureLoader.crossOrigin = '';
      textureLoader.load(url, (tex) => {
        tex.mapping = THREE.EquirectangularReflectionMapping;
        tex.colorSpace = THREE.SRGBColorSpace;
        // Use as a scene background (fast & clean), no extra meshes required
        scene.background = tex;
      });
    }

    // Try to use panorama.js if it provides a known hook
    // Expected (examples): window.initPanorama(url, three) OR window.PanoramaCreator.init(...)
    const tryPanoramaFromExternal = () => {
      try {
        if (window.initPanorama) {
          // Generic contract: initPanorama(url, THREE, scene)
          window.initPanorama(PANORAMA_IMAGE, THREE, scene);
          return true;
        }
        if (window.PanoramaCreator && typeof window.PanoramaCreator.init === 'function') {
          window.PanoramaCreator.init({ image: PANORAMA_IMAGE, THREE, scene });
          return true;
        }
      } catch(err){ console.warn('panorama.js present but failed, using fallback:', err); }
      return false;
    };

    if (!tryPanoramaFromExternal()) {
      addPanoramaFallback(PANORAMA_IMAGE);
    }

    // ====== LOAD FBX CHARACTER ======
    const loader = new FBXLoader();
    loader.load(
      FBX_MODEL_URL,
      (fbx) => {
        // Center and scale model
        fbx.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = false;
            child.receiveShadow = false;
            // Ensure sRGB
            if (child.material && child.material.map) {
              child.material.map.colorSpace = THREE.SRGBColorSpace;
            }
          }
        });

        // Auto-fit model height to ~1.8m, and place on ground Y=0
        const box = new THREE.Box3().setFromObject(fbx);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size); box.getCenter(center);
        const targetHeight = 1.8; // meters
        const scale = targetHeight / (size.y || 1);
        fbx.scale.setScalar(scale);
        fbx.position.y = - (box.min.y * scale); // put feet on ground
        fbx.position.z = 0; // center forward/back
        fbx.position.x = 0;
        scene.add(fbx);
      },
      undefined,
      (err) => console.error('FBX load error:', err)
    );

    // ====== RENDER LOOP ======
    let raf;
    const onResize = () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    };
    window.addEventListener('resize', onResize);

    const animate = () => {
      raf = requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    // Optional: slow auto-rotate panorama via camera orbit (no UI)
    const autoRotate = true;
    if (autoRotate){
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.4; // degrees/sec-ish
    }

    // Cleanup if needed (e.g., in SPA)
    window.addEventListener('beforeunload', () => cancelAnimationFrame(raf));
  </script>
</body>
</html>
